

 <font face='黑体' color='red' size=4>关键字</font>：结合不变差分比特的建模方法，自动搜索所需能成功攻击的不可能差分迹

## 1. 过去对SIMON的不可能差分攻击的错误之处

当密钥的扩散性太强时，不能用密钥比特的概念来计算剩余密钥及攻击复杂度，如$k_{in}\rightarrow ID \leftarrow k_{out}$ ，当密钥的**扩散性**太强时，$k_{in}$ 和 $k_{out}$ 的密钥比特之间的关系往往非常复杂，很难同时通过 $k_{in}$ 和 $k_{out}$ 的表达式关系将剩余密钥计算出来。这时，只能猜测$k_{in}$ 或 $k_{out}$ ，而将剩余密钥看成是随机数。

​假设猜测密钥经过不可能差分攻击后，每个密钥剩余的概率为 $p$ 。此时将$k_{in}$ 作为被猜测的密钥，则 $k_{in}$ 中剩余密钥的个数为：$(1-p\times 2^{k_{out}})\times 2^{k_{in}}$ 。穷搜的密钥个数为：$(1-p\times 2^{k_{out}})\times 2^{k_{in}}\times 2^{N-k_{in}}$ ，其中 $N$ 为密钥比特总数。 

**多重集合的重复筛选_**：对于重复出现了m次的元素，被筛选后留下的概率为p，则该元素被留下的概率：
$$
1-(1-p)^{m}
$$

​假设猜测密钥经过不可能差分攻击后，每个密钥剩余的概率为p。前面的扩展轮的被猜测的密钥比特个数为$k_{in}$ ，后面的扩展轮的被猜测的密钥比特个数为 $k_{out}$ 。经过筛选之后剩余的前面的扩展轮的被猜测密钥的个数为：
$$
m=(1-(1-p)^{2^{k_{out}}})\times 2^{k_{in}}
$$
穷搜的密钥个数为：$m\times 2^{N-k_{out}}=(1-(1-p)^{2^{k_{out}}})\times 2^{N}$ ，其中N为密钥比特的总数。

## 2. 与操作的性质 

​有一个与操作：$z=x\cdot y$ ，假设该操作的输入和输出差分分别为：$\Delta x,~\Delta y,~\Delta z$ 。一对明文中的其中一个分别是：$x,y,z$ 。则有如下的关系：
$$
\begin{align}
 \Delta z &=(\Delta x+ x)(\Delta y+ y)+x\cdot y \\
          &=\Delta x\cdot \Delta y+\Delta x \cdot y +\Delta y \cdot x +x\cdot y+x\cdot y \\
          &=\Delta x\cdot \Delta y+\Delta x\cdot y+\Delta y x
\end{align}
$$
对于该操作来说，当其中的一个比特的差分为1时，则影响到另一个比特的明文的密钥都会involved。

## 3.不可能差分攻击

### 3.1 两种轮密钥加的密码算法结构的攻击过程：

$$filter~(c_{0})\rightarrow key~(k_{0})\rightarrow filter~(c_{1})\rightarrow key~(k_{1})\rightarrow ID \leftarrow filter~(c_{2})\leftarrow key(k_{2})\leftarrow filter(c_{3})\leftarrow key(k_{3})$$
$$key(k_{0})\rightarrow filter(c_{0})\rightarrow key(k_{1})\rightarrow filter(c_{1})\rightarrow ID \leftarrow key(k_{2})\leftarrow filter(c_{2}) \leftarrow key(k_{3}) \leftarrow filter_(c_{3})$$

这两种密码算法结构都可归纳于以下的过程：$key_(k_{0})\rightarrow filter_(c_{0})\rightarrow ID \leftarrow filter(c_{1})\leftarrow key_(k_{1})$

所以攻击所需的时间复杂度为：
$$
T=Nk_{0}+\frac{N\times k_{0} \times k_{1}}{c_{0}}
$$
　　在计算时间复杂度的时候，加 key 操作所需的时间可忽略，因为其总是与其后的 filter 相连，故只考虑 filter 操作的时间即可。

### 3.2 不可能差分攻击的明密文对的构建过程

1. 给定m个明文，经过m次加密，输出m个密文。
2. 假设攻击所需的密文的差分模式为 ??101?11 ，建立一个hash表，index范围 0~$(2^{5}-1)$ ，将输出密文对应的非自由比特的值对应到index上，于是每个index下存储的所有的自由组合成为了所需的密文对。所需的存储为hash表的大小，也就是所需明文个数。

## 4. 攻击的三种方式

### **攻击的三种方法：**

1. 对每一对明密文对，测试所有密钥。

2. 对每一个密钥，测试所有明密文对。

3. 利用新的存储方式。

假如已给定不可能差分，且不可能差分攻击下的参数如下所示，前后向分别为 $r_{in},r_{out}$ 轮：

$$\Delta_{X_{0}}\xrightarrow[R_{0}]{(c_{in}^{0},k_{in}^{0})} \cdots \Delta_{X_{r_{in}-1}}\xrightarrow[R_{r_{in}-1}]{(c_{in}^{r_{in}-1},k_{in}^{r_{in}-1})} ID \xleftarrow[R_{r_{out}-1}]{(c_{out}^{r_{out}-1},k_{out}^{r_{out}-1})}\Delta_{Y_{r_{out}-1}} \cdots \xleftarrow[R_{0}]{(c_{out}^{0},k_{out}^{0})}\Delta_{Y_{0}}$$

输入明密文对个数为 $N$, 其中 $c_{i}$ 表示该轮的给定输入差分集合传播到输出差分集合的概率 $p_{i}=2^{c_{i}}$ ，$k_{i}$ 表示该轮所需猜测的密钥比特数，总共需要猜测 $2^{k_{i}}$ 个密钥，且测试顺序先前向轮，再后向轮。



### 1. 对每一对明密文对，测试所有密钥（先加密钥，后筛选）



- 第一对明文：

1. 第一轮：计算 $2^{k_{in}^{0}}$ 次，剩余的明文对个数为 $\frac{2^{k_{in}^{0}}}{2^{c_{in}^{0}}}$ 。

2. 第二轮：计算 $\frac{2^{k_{in}^{0}}}{2^{c_{in}^{0}}} \times 2^{k_{in}^{1}}$ 次，剩余的明文对个数为 $\frac{2^{k_{in}^{0}+k_{in}^{1}}}{2^{c_{in}^{0}+c_{in}^{1}}}$ 。

3. 最后一轮：计算 $\frac{2^{k_{in}^{0}+k_{in}^{1}+,\cdots,+k_{in}^{r_{in}-1}+k_{out}^{0}+k_{out}^{1}+,\cdots,+k_{out}^{r_{out}-1}}}{2^{c_{in}^{0}+,\cdots,+c_{in}^{r_{in}-1}+c_{out}^{0}+,\cdots,+c_{out}^{r_{out}-1}}}\times 2^{c_{out}^{r_{out}-1}}$ 次。（如果最后一轮是$ID\xrightarrow{}\Delta_{Y_{r_{out-1}}}$ ，该轮的攻击时间复杂度为：）



### 两种不同的筛选方式
以如下的简单的不可能差分攻击为例，其中已经选择的明密文对数为 $N$：
$$
\Delta X_{0} \xrightarrow[R_{0}]{(c_{0},k_{0})} \Delta X_{1}  \xrightarrow[R_{1}]{(c_{1},k_{1})}ID \xleftarrow[R_{3}]{c_{3},k_{3}} \Delta Y_{1} \xleftarrow[R_{2}]{c_{2},k_{2}} \Delta Y_{0}
$$

**对每一个密钥，测试所有的明密文对**

1. 令 $k_{0}=k_{0}^{1}$ ，则此时加密 $N$ 次，剩余的明文对数为 $\frac{N}{2^{c_{0}}}$ 。\
   令 $k_{1}=k_{1}^{1}$ ，则此时加密 $\frac{N}{2^{c_{0}}}$ 次，剩余的明文对数为 $\frac{N}{2^{c_{0}+c_{1}}}$ 。 \
   令 $k_{2}=k_{2}^{1}$ ，则此时加密 $\frac{N}{2^{c_{0}+c_{1}}}$ 次，剩余的明文对数为 $\frac{N}{2^{c_{0}+c_{1}+c_{2}}}$ 。\
   令 $k_{3}=k_{3}^{1}$ ，则此时加密 $x$ 次，$x$ 的值取决于几次之后就可以排除掉错误密钥。 

当$k_{0}||k_{1}||k_{2}||k_{3}$的值每变换一次，则 $R_{3}$ 需要运行 $x$ 次，所以最后一轮共需加密 $2^{k_{0}+k_{1}+k_{2}+k_{3}}\times x$ 次。 \
当$k_{0}||k_{1}$的值每变换一次，则 $k_{2}$ 需要遍历一次，所以 $R_{2}$ 的加密次数为$2^{k_{0}+k_{1}+k_{2}}\times \frac{N}{2^{c_{0}+c_{1}}}$ \
其他的同理，共需的时间复杂度为：
$$
T=2^{k_{0}}\times N +2^{k_{0}+k_{1}} \times \frac{N}{2^{c_{0}}}+ 2^{k_{0}+k_{1}+k_{2}}\times \frac{N}{2^{c_{0}+c_{1}}} + 2^{k_{0}+k_{1}+k_{2}+k_{3}}\times x
$$
所需的存储复杂度为存储明密文对：$N$ 。

2. 如果一对对地测试，即测试完第一对明密文后确定该密钥是否可行，时间复杂度为：
$$
2^{k_{0}+k_{1}+k_{2}+k_{3}}\times (N'+\frac{N'}{2^{c_{0}}}+\frac{N'}{2^{c_{0}+c_{1}}}+\frac{N'}{2^{c_{0}+c_{1}+c_{2}}})
$$
其中 $N'=2^{c_{0}+c_{1}+c_{2}+c_{3}}$
::: warning 有问题
如果不限制明文对的数量，则平均值为 $N'$ ,而事实上，有一部分不能测出来的密钥所经理的明密文对的个数是有上限的，所以实际值要比这个值偏小的。
:::

**对每一对明文，测试所有密钥**

第一对明文 $m^{0}$: 

1. 加密 $2^{k_{0}}$ 次，剩余 $\frac{2^{k_{0}}}{2^{c_{0}}}$ 对。
2. 加密 $\frac{k_{0}+k_{1}}{2^{c_{0}}}$ 次，剩余 $\frac{2^{k_{0}+k_{1}}}{2^{c_{0}+c_{1}}}$ 对。
   
第一对密文 $c^{0}$:

1. 加密 $k_{3}$ 次，剩余 $\frac{2^{k_{3}}}{2^{c_{2}}}$ 对。
2. 加密 $\frac{2^{k_{2}+k_{3}}}{2^{c_{2}}}$，剩余 $\frac{2^{k_{2}k_{3}}}{2^{c_{2}+c_{3}}}$ 对。

`前半部分`以key为index，存储明文对，平均一个key下存储 $\frac{N}{2^{c_{0}+c_{1}}}$对。\
`后半部分`以明文对为index，存储key，平均一个index下存储 $\frac{2^{k_{2}+k_{3}}}{2^{c_{2}+c_{3}}}$ 个密钥。 

**攻击时**, 假设我们已经得到了两部分的存储，在穷搜剩余密钥的时候，首先读取前半部分一个key下的所有的明文对，然后再读取后半部分所有明文对所对应的key，然后将这些key为index建立一个表，如果读到，则该表中的值为1，否则为0。然后在依次遍历该表即可。

时间复杂度为两部分：建表和读表
$$
T_{1}=N(2^{k_{0}}+\frac{2^{k_{0}+k_{1}}}{2^{c_{0}}}+2^{k_{2}}+\frac{2^{k_{2}+k_{3}}}{2^{c_{2}}})
$$
$$
T_{2}=2^{k_{0}+k_{1}}\times \frac{N}{2^{c_{0}+c_{1}}}\times \frac{2^{k_{2}+k_{3}}}{2^{c_{2}+c_{3}}}
$$
存储复杂度，三部分：前后两部分的表以及以key为index建立的一个读取表
$$
Memory=\frac{2^{k_{0}+k_{1}}}{2^{c_{0}+c_{1}}}\times N+\frac{2^{k_{2}+k_{3}}}{2^{c_{2}+c_{3}}} \times N +2^{k_{2}+k_{3}}
$$

**取得合格的明密文对的过程**

1. 首先选取一个structure，然后以密文中fix部分为index，存储对应的明文-密文
2. 通过组合一个index下的明文-密文，得到合格的明文-密文差分

如：(m0,c0)(m1,c1)(m2,c2)可以组成3对明密文差分(m0,c0)(m1,c1), (m0,c0)(m2,c2), (m1,c1)(m2,c2)。